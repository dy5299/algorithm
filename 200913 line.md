# 1

###### 문제 설명

창고에 재고로 쌓여 있는 상품들을 재포장하려고 합니다. 재포장을 완료하기 위해 추가로 구매해야 하는 상품이 몇 개인지 구하고자 합니다.

창고에는 상품이 2개씩 들어있는 상자가 쌓여있습니다. 한 상자 안에 들어있는 2개의 상품이 같은 종류인 경우도 있고 아닌 경우도 있습니다. 1+1 행사를 위해 모든 상자 안에 같은 종류의 상품을 2개씩 넣고 포장하려고 합니다. 일단, 상품의 짝이 맞지 않는 상자끼리 서로 필요한 물건을 교환해서 최대한 많은 짝을 맞춰 재포장합니다. 그렇게 했음에도 짝을 맞추기에 수량이 부족한 상품은 추가 구매합니다. 단, 상자는 원래 창고에 쌓여있던 개수만큼 사용할 수 있으며, 추가로 더 가져오거나 구입하지 못합니다.

아래 예시는 재포장을 진행하기 전, 각 상자에 들어있는 상품들의 종류를 나타냅니다.

| 상자 번호 | 상품 종류 |
| --------- | --------- |
| 1번 상자  | 1, 2      |
| 2번 상자  | 2, 1      |
| 3번 상자  | 3, 3      |
| 4번 상자  | 4, 5      |
| 5번 상자  | 5, 6      |
| 6번 상자  | 7, 8      |

1번 상자에서는 2번 상품을, 2번 상자에서는 1번 상품을 서로 교환하면 두 상자의 짝 맞추기가 해결됩니다. 3번 상자는 이미 짝이 맞추어져 있기 때문에 다른 상자와 교환할 필요가 없습니다. 4번 상자는 4번 상품을 5번 상자에 들어있는 5번 상품과 교환하면 짝을 맞출 수 있습니다. 5번과 6번 상자는 남아 있는 상품들로 짝을 맞출 수 없기 때문에 상품의 추가 구매가 필요합니다. 이때, 2개의 상품만 구매하면 짝을 맞출 수 있습니다. 예를 들어, 4번과 6번 상품을 구매하면 각각 짝을 만들 수 있습니다.

각 상자에 들어있는 상품의 종류를 나타내는 2차원 배열 boxes가 매개변수로 주어집니다. 상품의 짝을 맞춰 재포장을 완료하기 위해 추가로 구매해야 하는 상품의 최소 개수를 return 하도록 solution 함수를 작성해주세요.

------

##### 제한사항

- boxes의 길이(=창고에 재고로 쌓인 상자 개수)는 1 이상 100,000 이하입니다.
  - boxes의 원소는 2개의 상품이 들어있는 상자를 나타냅니다.
  - boxes의 원소는 `[a, b]` 형태의 배열입니다.
  - `a`와 `b`는 상자 안에 들어있는 상품의 종류를 나타냅니다.
  - `a`와 `b`는 1 이상 1,000,000 이하인 자연수입니다.
- 모든 상품 종류에 대해 추가 구매 가능한 수량은 무한합니다.

------

##### 입출력 예

| boxes                                            | result |
| ------------------------------------------------ | ------ |
| [[1, 2], [2, 1], [3, 3], [4, 5], [5, 6], [7, 8]] | 2      |
| [[1, 2], [3, 4], [5, 6]]                         | 3      |
| [[1, 2], [2, 3], [3, 1]]                         | 0      |

------

##### 입출력 예 설명

입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
상자끼리 물건을 교환해서 짝 지을 수 있는 경우가 없습니다. 이미 있는 상품 종류 중에서 3가지를 골라, 한 개씩 추가 구매해야 합니다. 예를 들어, 1번, 3번, 5번 상품을 한 개씩 추가 구매하여 세 쌍을 만들 수 있습니다.

입출력 예 #3
상자끼리 서로 물건을 교환해서 모두 짝을 맞출 수 있습니다. 상품의 추가 구매가 필요하지 않습니다.

```
def solution(boxes):
    answer = -1
    return answer
```

# 2

###### 문제 설명

왼쪽 또는 오른쪽으로만 빠져나갈 수 있는 원통형 파이프 안에 숫자가 쓰인 공이 일렬로 들어있습니다. 명령에 따라 공을 하나씩 뺄 때, 공이 빠져나오는 순서를 구하려고 합니다.

양방향 중 한 방향으로 공을 하나씩 뺄 수 있기 때문에, 명령받은 공이 다른 공 사이에 있어 바로 빠져나오지 못하는 경우도 있습니다. 양쪽 끝에 있는 두 개의 공만 명령에 따라 바로 뺄 수 있습니다. 명령을 받았지만 바로 뺄 수 없는 공은 보류 상태가 되며, 뺄 수 있는 조건이 되면 다음 명령보다 우선하여 빠져나오게 됩니다.

아래 그림은 파이프 안에 들어있는 공의 순서를 나타냅니다.

![green_ball.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/17f21b69-532f-4bbd-9de3-aa8663fdfa0f/green_ball.png)

명령이 `[6, 2, 5, 1, 4, 3]`으로 주어진 경우, 다음과 같이 공이 빠져나오게 됩니다.

```
1. 6번 공은 오른쪽 끝에 있으므로 바로 빠져나옵니다.
2. 2번 공은 다른 공 사이에 있기 때문에 바로 나가지 못하고 보류 상태가 됩니다.
3. 5번 공은 6번 공이 빠져나갔기 때문에 오른쪽 끝에 있으므로 바로 빠져나옵니다.
4. 1번 공은 왼쪽 끝에 있으므로 바로 빠져나옵니다. 보류 상태였던 2번 공이 이제 빠져나올 수 있기 때문에 뒤이어 2번 공이 빠져나옵니다.
5. 4번 공은 오른쪽 끝에 있으므로 바로 빠져나옵니다.
6. 3번 공은 마지막 공이기 때문에 어느 쪽으로든 나올 수 있습니다.
```

공이 빠져나온 순서는 `[6, 5, 1, 2, 4, 3]`입니다.

파이프에 들어있는 공의 번호를 나타내는 배열 ball과 공을 빼는 명령을 담은 배열 order가 매개변수로 주어집니다. 공이 빠져나오는 순서를 배열에 담아 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- ball의 길이(=공의 개수)는 1 이상 300,000 이하입니다.
- ball의 모든 원소는 1 이상 1,000,000 이하인 자연수입니다.
  - ball에는 같은 숫자가 중복해서 들어있지 않습니다.
- order의 길이는 ball의 길이와 같습니다.
- order의 원소는 ball의 원소와 일대일 대응입니다.

------

##### 입출력 예

| ball               | order              | result             |
| :----------------- | :----------------- | :----------------- |
| [1, 2, 3, 4, 5, 6] | [6, 2, 5, 1, 4, 3] | [6, 5, 1, 2, 4, 3] |
| [11, 2, 9, 13, 24] | [9, 2, 13, 24, 11] | [24, 13, 9, 2, 11] |

------

##### 입출력 예 설명

입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
첫 번째 명령부터 세 번째 명령에 해당하는 공은 모두 바로 뺄 수 없기 때문에 보류 상태가 됩니다. 24번 공이 빠져나오면 보류 상태였던 공이 연이어 나오게 됩니다.

```
def solution(ball, order):
    answer = []
    return answer
```

# 3

###### 문제 설명

덧셈 기호 '+'를 사용해 어떤 수를 한 자리 수로 만들고자 합니다. 수를 하나의 문자열로 생각했을 때, 숫자와 숫자 사이 중 한 곳에 덧셈 기호를 삽입할 수 있습니다. 덧셈 기호가 삽입되면 원래의 수는 덧셈 기호를 사이에 둔, 두 수의 합을 나타내는 식이 됩니다. 이 식을 계산하여 이전의 수보다 작은 새로운 수를 만들 수 있습니다. 덧셈 기호를 삽입할 수 없는 한 자릿수가 나올 때까지 이 작업을 반복합니다.

아래 예시는 `73425`를 한 자릿수로 만드는 방법 2가지를 나타냅니다. `→`는 덧셈 기호의 사용을 나타냅니다.

```
방법 1.
(73425) → (7 + 3425 = 3432) → (3 + 432 = 435) → (4 + 35 = 39) → (3 + 9 = 12) → (1 + 2 = 3)

방법 2.
(73425) → (73 + 425 = 498) → (49 + 8 = 57) → (5 + 7 = 12) → (1 + 2 = 3)
```

위의 2가지 방법 중 두 번째가 덧셈 기호 사용 횟수를 최소로 하여 한 자릿수를 만드는 방법입니다. 4회 만에 한 자릿수를 만드는 다른 방법도 있지만, 다른 어떤 방법으로도 4회보다 적은 횟수로 한 자릿수를 만들 수 없습니다. 그리고 연산 과정이 끝난 후 만들어진 한 자릿수는 3입니다.

10억 이하의 자연수 n이 매개변수로 주어집니다. 덧셈 기호를 가장 적게 사용해 n을 한 자릿수로 만들 때, 덧셈 기호 사용 횟수 `a`와 연산 과정 끝에 만들어진 한 자릿수 `b`를 배열에 담아 `[a, b]` 형식으로 return 하도록 solution함수를 작성해주세요.

------

##### 제한사항

- n은 1 이상 10억 이하의 자연수입니다.
- 0을 제외하고 '0'으로 시작하는 수는 유효하지 않습니다. 예를 들어, 00이나 09는 유효한 수가 아닙니다.
- 덧셈 기호 사용을 최소로 하는 방법이 여러 개일 경우, 그 결과로 만들어진 한자리 수는 어떤 것을 반환해도 상관없습니다.

------

##### 입출력 예

| n     | result |
| ----- | ------ |
| 73425 | [4, 3] |
| 10007 | [4, 8] |
| 9     | [0, 9] |

------

##### 입출력 예 설명

입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
0을 제외하고 07 또는 007과 같이 '0'으로 시작하는 수는 유효하지 않기 때문에 `(10007) → (1000 + 7)`과 같이 덧셈 기호를 7 바로 앞에 삽입해야 합니다. 이후 단계에서도 같은 조건을 따르면, 덧셈 기호 사용 횟수 4와 한 자릿수 8을 구할 수 있습니다.

입출력 예 #3
입력으로 주어진 수가 이미 한 자릿수이기 때문에 덧셈 기호를 삽입할 수 없습니다. 그러므로 삽입 횟수 0과 입력으로 주어진 수 9를 그대로 배열에 담아 반환합니다.

```
def solution(n):
    answer = []
    return answer
```

# 4

###### 문제 설명

미로를 탈출하는 방법 중에 왼손법칙이라는 것이 있습니다. 이 방법은 미로의 벽에 왼쪽 손을 대고 계속 걷는 방법입니다. 왼손법칙을 이용했을 때, 미로를 탈출하는 데 걸리는 시간을 구하려고 합니다.

1 x 1 크기 정사각 칸으로 이루어진 N x N 크기의 미로가 주어집니다. 미로를 탈출하는 사람은 0행 0열에서 시작하며, `N-1`행 `N-1`열에 도착하면 탈출에 성공합니다. 1초에 상하좌우 한 칸씩 이동할 수 있으며, 대각선으로 이동할 수 없습니다.

아래 그림은 미로를 탈출하려는 사람의 초기 위치와 미로의 구조를 나타냅니다. 0과 1은 각각 비어있는 공간과 벽을 나타냅니다.

![example0_start0.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/63632ffa-33c9-47b6-b942-3f4d0b5f934b/example0_start0.png)

0행 0열부터 왼손을 벽에 대고 걷게 되면 아래 그림에 표시된 화살표를 따라 미로를 순회합니다.

![example0_start0_arrow.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/560138bc-4d38-41da-bc01-1faecae5eb89/example0_start0_arrow.png)

위 그림과 같이 미로를 순회하게 되면 총 10회의 칸 이동을 하게 됩니다. 즉, 미로를 탈출하는 데 10초가 걸립니다.

미로를 나타내는 2차원 배열 maze가 매개변수로 주어집니다. 왼손법칙을 이용해 미로를 탈출할 때 걸리는 시간을 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- maze는 2차원 정사각 배열로, 길이는 3 이상 300 이하입니다.
- maze의 각 원소의 값은 0 또는 1입니다.
  - 배열의 가장 왼쪽 상단과 가장 오른쪽 하단은 각각 시작 지점과 종료 지점으로, 항상 0입니다.
  - 원소의 값 0은 칸이 비어 있어 이동이 가능함을, 1은 벽으로 채워져 있어 이동이 불가능함을 나타냅니다.
- maze는 항상 왼손법칙을 이용해 탈출할 수 있는 형태로 주어집니다.

------

##### 입출력 예

| maze                                                         | result |
| ------------------------------------------------------------ | ------ |
| [[0, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 1, 0]]     | 10     |
| [[0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0]] | 32     |
| [[0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0]] | 24     |
| [[0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0]] | 22     |

------

##### 입출력 예 설명

입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2

![example1_start0.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d86bc3e4-1c60-4a23-963e-4fdc3eb780e1/example1_start0.png)

위와 같이 이동하면 32초가 걸립니다.

입출력 예 #3

![example2_start0.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/07177970-f7a2-4ff9-9ed0-1b43b0c688e3/example2_start0.png)

위와 같이 이동하면 24초가 걸립니다.

입출력 예 #4

![example3_start0.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/60d5f8eb-30c1-4571-aa40-8cdd7bec3e7f/example3_start0.png)

0행 1열에 벽이 없는 경우, 0행 0열 칸의 위쪽 벽에 왼손을 대고 열이 증가하는 방향으로 이동합니다. 위와 같이 이동하면 22초가 걸립니다.

```
def solution(maze):
    answer = 0
    return answer
```

# 5

###### 문제 설명

블랙잭은 플레이어가 딜러와 하는 게임이며 규칙이 상당히 쉽습니다. 카드의 합이 21을 넘지 않는 한도 내에서 카드를 한 장씩 계속해서 받거나 중단하여 21에 더 가까운 사람이 이기는 게임입니다. 실제 규칙을 간소화하여 다음과 같이 게임을 진행합니다.

```
1. 딜러가 카드를 한 장 뽑아 플레이어에게 준다.
2. 딜러가 카드를 한 장 뽑아 딜러 앞에 뒤집어 놓는다.
3. 딜러가 카드를 한 장 뽑아 플레이어에게 준다.
4. 딜러가 카드를 한 장 뽑아 딜러 앞에 보이도록 놓는다.
5. 플레이어에게 카드를 더 받을지 말지 물어본다.
    5.1 플레이어가 최초로 받은 카드 두 장의 합이 21인 경우에는 더 이상 카드를 받지 않고, 딜러의 카드를 확인하여 승패를 결정한다.
    5.2 플레이어가 받은 모든 카드의 합이 21보다 작으면 계속해서 한 장씩 더 받을 수 있다.
    5.3 플레이어가 받은 모든 카드의 합이 21을 넘어가면 플레이어가 즉시 게임에서 진다.
6. 플레이어가 더이상 카드를 받지 않으면 딜러 앞의 뒤집어놓은 카드를 공개한 후, 딜러의 카드 합이 17 이상이 될 때까지 계속해서 카드를 한 장씩 받는다.
    6.1 딜러의 카드 합이 21을 넘으면 딜러가 즉시 게임에서 진다.
    6.2 이때 딜러는 플레이어가 가진 카드 합을 고려하지 않으며 카드합이 17 이상이 되면 받기를 중단한다.
7. 승패를 가린다. 카드 합이 21에 더 가까운 사람이 이기며, 카드 합이 서로 같으면 비긴다.
```

간단한 규칙 때문에 블랙잭에는 유명한 전략이 존재합니다. 위의 5번 과정에서 딜러의 카드 중 보이는 카드에 따라 플레이어는 다음과 같은 전략을 따릅니다.

```
1. 딜러의 보이는 카드가 1이거나 7 이상인 경우, 플레이어는 카드 합이 17 이상이 될 때까지 받는다.
2. 딜러의 보이는 카드가 4, 5, 6인 경우, 플레이어는 카드를 받지 않는다.
3. 딜러의 보이는 카드가 2, 3인 경우, 플레이어는 카드 합이 12 이상이 될 때까지 받는다.
```

블랙잭 룰에 따라 J, Q, K에 해당하는 11, 12, 13은 모두 10으로 치환합니다. A에 해당하는 1은 1 또는 11로 치환이 가능하며 카드를 가진 사람에게 유리하게 적용이 가능합니다. 예를 들어, 카드 합을 적어도 17 이상으로 만들고 싶을 때 카드가 `[1, 6]`이면 1을 11로 치환하여 카드 합을 17로 계산할 수 있습니다. 만약 카드가 `[1, 5, 10]` 일 때는 1을 그대로 1로 사용함으로써 카드 합을 16으로 계산할 수 있습니다.

딜러와 플레이어 모두 `1` 카드를 11로 치환하여 원하는 카드 합을 만들 수 있다면 항상 11로 치환하여 계산합니다. 예를 들어, 원하는 카드 합이 17 이상이고 플레이어의 카드가 `[5, 1, 1]`인 경우, `1` 한 장만 11로 치환한다면 카드 합이 17이고, 두 장 모두 1로 사용한다면 카드 합이 7입니다. 이때 플레이어는 카드 합을 7로 계산해서 뒤에 더 좋은 카드를 받는 것을 기대할 수도 있지만, 여기에서는 17로 계산하고 더 이상 카드를 받지 않습니다.

`[10, 1]`과 같이 처음 받은 두 카드의 합이 21이면 `블랙잭`이라고 합니다(5.1번 규칙). 플레이어가 블랙잭일 경우 바로 딜러의 카드를 확인하여 딜러가 블랙잭이 아니라면(즉, 딜러의 카드 두 장의 합이 21이 아니라면) 플레이어가 승리하며, 베팅한 금액의 `1.5`배를 받습니다. 플레이어가 게임에서 진 경우에는 항상 베팅한 금액만큼만 잃습니다. 서로 비긴 경우에는 돈을 따지도 잃지도 않습니다.

플레이어는 게임에서 이기면 2원을 얻고, 지면 2원을 잃습니다. 또, 블랙잭으로 승리한 경우에는 3원을 얻습니다. 처음에 플레어가 가진 돈은 0원에서 시작하며, 돈은 음수가 될 수 있다고 가정합니다. 뽑을 카드들을 순서대로 나타내는 배열 cards가 매개변수로 주어집니다. 위의 전략대로 플레이할 경우, 모든 게임이 끝나고 플레이어가 가진 돈의 액수를 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- cards의 길이는 1 이상 10,000 이하입니다.
  - cards의 원소는 1 이상 13 이하의 자연수입니다.
- 더 이상 카드를 뽑을 수 없는 경우 해당 게임을 무효처리하고 종료합니다. 무효처리된 게임에서는 돈을 따지도, 잃지도 않습니다.

------

##### 입출력 예

| cards                             | result |
| --------------------------------- | ------ |
| [12, 7, 11, 6, 2, 12]             | 2      |
| [1, 4, 10, 6, 9, 1, 8, 13]        | 1      |
| [10, 13, 10, 1, 2, 3, 4, 5, 6, 2] | -2     |
| [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]    | -2     |

------

##### 입출력 예 설명

입출력 예 #1

| 카드 번호 | 설명                                  |
| --------- | ------------------------------------- |
| 12        | 플레이어가 카드 Q를 받습니다.         |
| 7         | 딜러 앞에 카드 7을 뒤집어 놓습니다.   |
| 11        | 플레이어가 카드 J를 받습니다.         |
| 6         | 딜러 앞에 카드 6을 보이도록 놓습니다. |
| 2         | 딜러가 카드 2를 받습니다.             |
| 12        | 딜러가 카드 12를 받습니다.            |

플레이어가 처음 받은 두 장의 카드는 12, 11이며 카드 합이 20입니다. 플레이어는 딜러의 공개된 카드가 6이므로 카드를 받지 않습니다. 딜러의 카드는 7, 6이며 카드 합이 13입니다. 17보다 작기 때문에 카드를 더 받습니다. 카드 2를 받으면 딜러의 카드 합이 15가 되며, 아직 17보다 작기 때문에 카드를 한 장 더 받습니다. 카드 12를 받는 순간 카드 합이 25가 되어 21을 초과하므로 딜러가 지고, 플레이어가 2원을 얻습니다.

입출력 예 #2
플레이어가 처음 받은 두 장의 카드 합이 21이므로 블랙잭입니다. 딜러의 카드는 4, 6으로 카드 합이 10이지만 플레이어가 블랙잭이기 때문에 카드를 더 받지 못하고 딜러가 패배합니다. 플레이어는 블랙잭으로 승리했기 때문에 3원을 땁니다. 다음 게임에서 플레이어의 카드 합이 17이고 딜러가 블랙잭입니다. 게임에서 졌기 때문에 플레이어는 2원을 잃습니다. 결국 플레이어가 딴 돈의 합계는 1원입니다.

입출력 예 #3
첫 번째 게임은 플레이어의 카드 합이 20, 딜러가 블랙잭이므로 2원을 잃습니다. 두 번째 게임에서 플레이어의 카드합은 6이지만, 딜러의 보이는 카드가 5이므로 카드를 받지 않습니다. 딜러가 가진 카드의 합은 8이므로 다음 카드 6, 2를 받습니다. 딜러의 현재 카드 합은 16이며, 카드 합이 17 이상이 될 때까지 카드를 받아야 하는데, 더 이상 뽑을 카드가 없으므로 해당 게임은 무효 처리합니다. 결국 플레이어가 딴 돈의 합계는 -2원 입니다.

입출력 예 #4
플레이어가 처음 받은 두 장의 카드 합이 6입니다. 딜러의 공개된 카드가 3이므로 플레이어는 카드 합이 12 이상이 될 때까지 카드를 받습니다. 카드 3을 2장 더 받아서 카드 합 12를 만들면 더 이상 카드를 받지 않습니다. 딜러는 카드 합이 17 이상이 될 때까지 카드를 받습니다. 카드 3을 4장 더 받아서 카드 합이 18이 되고, 딜러가 승리합니다. 결국 플레이어가 딴 돈의 합계는 -2원 입니다.

```
def solution(cards):
    answer = -1
    return answer
```

# 6

###### 문제 설명

다양한 기업과 많은 지원자들이 참여한 대규모 공개 채용 이벤트가 진행되었습니다. 마침내 엄청난 경쟁을 뚫고 올라온 N명의 지원자들이 M개의 기업에 입사할 수 있는 기회를 얻었습니다. 이벤트 진행자는 설문을 통해 각 기업으로부터 지원자 선호 순위와 채용 인원수를 수집했고, 각 지원자로부터 기업 선호 순위와 입사를 희망하는 기업 수를 수집했습니다. 이 정보를 이용해 기업과 지원자들을 매칭 하려고 합니다.

아래 표 2개는 각각 기업과 지원자의 설문 조사 내용을 나타냅니다. 기업의 이름은 알파벳 대문자로, 지원자의 이름은 알파벳 소문자로 나타냅니다.

첫 번째 표는 각 기업이 선호하는 지원자의 순위와 채용하고자 하는 인원수를 나타냅니다. `>`의 오른쪽에 있을수록 선호도가 낮음을 의미합니다.

| 기업 | 지원자에 대한 선호도  | 채용 인원 수 |
| ---- | --------------------- | ------------ |
| A    | f > a > b > d > e > c | 2            |
| B    | c > e > b > d > f > a | 2            |
| C    | e > c > f > a > d > b | 2            |

두 번째 표는 각 지원자가 선호하는 기업의 순위와 입사하고자 하는 기업의 수를 나타냅니다. 어떤 지원자의 입사 희망 기업 수가 1일 경우, 선호도 상위 1위 기업에만 입사할 의지가 있음을 나타냅니다.

| 지원자 | 기업에 대한 선호도 | 입사 희망 기업 수 |
| :----- | :----------------- | :---------------- |
| a      | B > A > C          | 1                 |
| b      | B > A > C          | 3                 |
| c      | B > C > A          | 2                 |
| d      | A > B > C          | 3                 |
| e      | B > C > A          | 3                 |
| f      | A > B > C          | 2                 |

다음 과정을 따라 기업과 지원자를 매칭 합니다.

```
1단계. 지원자는 거절당하지 않았던 기업 중에서 자신의 선호도가 가장 높은 기업 한 곳에 지원합니다. 입사 희망 기업으로부터 모두 거절당하면 지원을 중단합니다.

2단계. 기업은 채용 인원수를 넘지 않는 한도 내에서 선호도가 높은 순서대로 지원자를 잠정 선택합니다. 선택하지 않은 지원자들은 거절합니다.

3단계. 거절당한 지원자들 중에서 다른 기업에 지원할 지원자가 있다면 1단계부터 반복하고, 없다면 현재의 잠정 선택을 최종 매칭으로 결정합니다.
```

아래 그림은 기업과 지원자를 매칭 하는 과정입니다. 총 4라운드를 거치며, 밑줄은 기업이 잠정 선택한 지원자를 나타냅니다. 화살표는 거절당한 지원자가 다음 라운드에 지원하는 기업을 가리킵니다.

![matching5.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d9a037ee-b552-48da-b61b-59d3d7db110e/matching5.png)

1라운드에서는 모든 지원자가 각자 가장 선호하는 기업에 지원합니다. A기업은 채용인원이 2명이기 때문에 지원자 2명을 잠정 선택합니다. B기업은 채용인원이 2명인데 4명이 지원을 했기 때문에 B기업이 선호하는 c, e를 잠정 선택하고 a, b는 거절합니다. 거절당한 a는 입사 희망 기업이 오직 B이기 때문에 더 이상 다른 기업에 지원하지 않습니다.
2라운드에서는 B에게 거절당했던 b가 B 다음으로 선호하는 A기업에 지원합니다. A기업은 3명의 지원자 중 선호도가 높은 f, b를 잠정 선택하고 d는 거절합니다.
3라운드에서는 d가 B기업에 지원합니다. B기업은 3명 중 선호도가 높은 c, e를 잠정 선택하고 d는 거절합니다.
4라운드에서는 d가 C기업에 지원합니다. C기업은 지원자의 수가 채용인원수 이하이기 때문에 d를 잠정 선택합니다. 더 이상 다른 기업에 지원할 지원자가 없기 때문에 매칭을 종료합니다.

매칭 결과, A기업에는 b, f 지원자가, B기업에는 c, e 지원자가, C기업에는 d 지원자가 매칭 되었습니다.

기업 이름과 지원자 순위, 채용 인원수를 나타내는 문자열 배열 companies와, 지원자 이름과 기업 순위, 입사 희망 기업 수를 나타내는 문자열 배열 applicants가 매개변수로 주어집니다. 매칭 결과를 각 기업마다 `"기업 이름_오름차순으로 정렬된 지원자 이름"`형식의 문자열로 나타내어 배열에 담은 후, 기업 이름으로 오름차순 정렬하여 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- companies의 길이(=`전체 기업의 수`)는 1 이상 26 이하입니다.

- companies 배열의 원소는

   

  기업이름 지원자순위 채용인원

   

  형식입니다.

  - 기업이름은 알파벳 대문자 A-Z 중 하나입니다.
  - 지원자순위는 모든 지원자 이름이 공백 없이 선호도를 기준으로 내림차순 정렬되어 있습니다. 즉, 기업이 가장 선호하는 지원자가 가장 앞에 나타납니다.
  - 채용인원은 기업이 채용하고자 하는 인원으로 1 이상 `전체 지원자 수` 이하인 자연수입니다.
  - 모든 기업들의 채용인원 합은 `전체 지원자 수`와 같습니다.

- applicants의 길이(=`전체 지원자 수`)는 1 이상 26 이하입니다.

- applicants 배열의 원소는

   

  지원자이름 기업순위 기업수

   

  형식입니다.

  - 지원자 이름은 알파벳 소문자 a-z 중 하나입니다.
  - 기업순위는 모든 기업이름이 공백 없이 선호도를 기준으로 내림차순 정렬되어 있습니다. 즉, 지원자가 가장 선호하는 기업이 가장 앞에 나타납니다.
  - 기업수는 지원자가 입사를 희망하는 선호도 상위 기업 수를 나타내며, 1 이상 `전체 기업의 수` 이하인 자연수입니다.

------

##### 입출력 예

| companies                                    | applicants                                                   | result                    |
| :------------------------------------------- | :----------------------------------------------------------- | :------------------------ |
| `["A fabdec 2", "B cebdfa 2", "C ecfadb 2"]` | `["a BAC 1", "b BAC 3", "c BCA 2", "d ABC 3", "e BCA 3", "f ABC 2"]` | `["A_bf", "B_ce", "C_d"]` |
| `["A abc 2", "B abc 1"]`                     | `["a AB 1", "b AB 1", "c AB 1"]`                             | `["A_ab", "B_"]`          |

------

##### 입출력 예 설명

입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
모든 지원자들이 A기업에만 입사하기를 희망합니다. A기업으로부터 거절당한 c지원자는 더 이상 다른 기업에 지원하지 않으며, B기업은 매칭 된 지원자가 없습니다.

```
def solution(companies, applicants):
    answer = []
    return answer
```

