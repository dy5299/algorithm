# 1

###### 문제 설명

당신은 대학생으로, 졸업 직전 각 과목별로 받은 성적을 정리해두었습니다. 당신은 수강한 과목들의 고유 가중치와 성적 가중치의 곱을 모두 합한 값이 일정 기준 이상인지 아닌지를 알고자 합니다.

먼저, 가능한 성적의 목록은 다음과 같습니다.

| 성적 | 성적 가중치 |
| ---- | ----------- |
| A+   | 10          |
| A0   | 9           |
| B+   | 8           |
| B0   | 7           |
| C+   | 6           |
| C0   | 5           |
| D+   | 4           |
| D0   | 3           |
| F    | 0           |

또한, 각 과목에는 고유 가중치가 붙어있습니다. 만약 어떤 과목이 3만큼의 고유 가중치를 가지고, 당신이 이 과목에서 B0를 받았다면, 당신은 21만큼의 점수를 얻게 됩니다.

과목별 당신의 성적을 의미하는 문자열 배열 grades, 과목별 고유 가중치를 의미하는 정수 배열 weights, 그리고 졸업 기준 threshold가 매개변수로 주어집니다. 당신이 얻은 점수의 합에서 threshold를 뺀 값을 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- grades의 길이는 1 이상 1,000 이하입니다.
  - grades의 모든 문자열은 A+, A0, B+, B0, C+, C0, D+, D0, F 중 하나입니다.
  - `grades[i]`는 i+1번째 과목의 성적을 의미합니다.
- weights의 길이는 grades의 길이와 같습니다.
  - weights의 모든 수는 1 이상 1,000 이하입니다.
  - `weights[i]`는 i+1번째 과목의 고유 가중치를 의미합니다.
- threshold는 1 이상 20,000,000 이하입니다.

------

##### 입출력 예

| grades                 | weights      | threshold | result |
| ---------------------- | ------------ | --------- | ------ |
| `["A+","D+","F","C0"]` | `[2,5,10,3]` | 50        | 5      |
| `["B+","A0","C+"]`     | `[6,7,8]`    | 200       | -41    |

------

##### 입출력 예 설명

입출력 예 #1

- 점수를 계산하는 과정은 다음과 같습니다.

| 과목 번호 | 성적    | 학점 | 점수 |
| --------- | ------- | ---- | ---- |
| 1번       | A+ (10) | 2    | 20   |
| 2번       | D+ (4)  | 5    | 20   |
| 3번       | F (0)   | 10   | 0    |
| 4번       | C0 (5)  | 3    | 15   |

- 따라서, 총 점수는 55이므로, 여기서 threshold(=50)을 뺀 5를 return 해야 합니다.

입출력 예 #2

- 점수를 계산하는 과정은 다음과 같습니다.

| 과목 번호 | 성적   | 학점 | 점수 |
| --------- | ------ | ---- | ---- |
| 1번       | B+ (8) | 6    | 48   |
| 2번       | A0 (9) | 7    | 63   |
| 3번       | C+ (6) | 8    | 48   |

- 따라서, 총 점수는 159이므로, 여기서 threshold(=200)을 뺀 -41을 return 해야 합니다.

# 2

###### 문제 설명

당신은 친구가 만든 암호문을 해석하고자 합니다. 암호문은 다음과 같은 2개의 요소로 구성되어 있습니다.

- 숫자 문자열
- 사칙연산 기호

당신은 이 암호문을 해독하는 방법이 바로 숫자 문자열을 2개의 작은 문자열로 분할한 뒤, 두 문자열을 정수로 변환해서 사칙연산 기호에 맞는 연산을 시킨 결과임을 알고 있습니다. 하지만 당신은 숫자 문자열의 어느 부분을 기준으로 하여 이 문자열을 분할해야 할지 모르기 때문에, 모든 경우를 전부 나열하기로 했습니다.

암호문의 숫자 문자열 s와 사칙연산 기호 op가 매개변수로 주어집니다. s를 왼쪽 문자열의 길이가 1, 2, 3, ..., (s의 길이 - 1)이 되도록 두 문자열로 분할했을 때, 암호 해독 결과를 차례대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- s의 길이는 2 이상 10 이하입니다.
- op는 `"+", "-", "*"` 중 하나입니다.

------

##### 입출력 예

| s          | op    | result                        |
| ---------- | ----- | ----------------------------- |
| `"1234"`   | `"+"` | `[235,46,127]`                |
| `"987987"` | `"-"` | `[-87978,-7889,0,9792,98791]` |
| `"31402"`  | `"*"` | `[4206,12462,628,6280]`       |

------

##### 입출력 예 설명

입출력 예 #1

- s = 1234, op = `"+"` (덧셈)입니다.
- s를 해독하는 모든 경우의 수는 다음과 같습니다.

| s 왼쪽 | s 오른쪽 | 암호 해독 결과 |
| ------ | -------- | -------------- |
| 1      | 234      | 235            |
| 12     | 34       | 46             |
| 123    | 4        | 127            |

- 따라서, `[235,46,127]`을 return 해야 합니다.

입출력 예 #2

- s = 987987, op = `"-"` (뺄셈)입니다.
- s를 해독하는 모든 경우의 수는 다음과 같습니다.

| s 왼쪽 | s 오른쪽 | 암호 해독 결과 |
| ------ | -------- | -------------- |
| 9      | 87987    | -87978         |
| 98     | 7987     | -7889          |
| 987    | 987      | 0              |
| 9879   | 87       | 9792           |
| 98798  | 7        | 98791          |

- 따라서, `[-87978,-7889,0,9792,98791]`을 return 해야 합니다.

입출력 예 #3

- s = 31402, op = `"*"` (곱셈)입니다.
- s를 해독하는 모든 경우의 수는 다음과 같습니다.

| s 왼쪽 | s 오른쪽 | 암호 해독 결과 |
| ------ | -------- | -------------- |
| 3      | 1402     | 4206           |
| 31     | 402      | 12462          |
| 314    | 02       | 628            |
| 3140   | 2        | 6280           |

- 따라서, `[4206,12462,628,6280]`을 return 해야 합니다.

# 3

###### 문제 설명

마틴게일 베팅법이란, 게임에서 돈을 잃으면 그다음 판에 잃은 돈의 두 배를 다시 베팅하는 전략입니다. 동전 앞뒤 맞추기 게임에서 이 베팅법을 사용했을 때 돈을 얼마나 딸 수 있는지 보려고 합니다.

동전 앞뒤 맞추기 게임에서는 이기면 걸었던 액수만큼 돈을 딸 수 있고, 지면 걸었던 액수만큼 돈을 잃습니다.

당신은 첫 판에 항상 `100원`을 겁니다. 그리고 마틴게일 베팅법에 따라 게임에서 지면 잃은 돈의 두 배를 다음 판에 베팅합니다. 예를 들어, 한 번 지면 다음 판에 100원의 2배인 200원을 걸게 되고, 200원을 걸었는데도 또 지면 다음 판에 200원의 2배인 400원을 걸게 됩니다. 연속해서 지는 도중에 한 번이라도 이긴다면 다시 기본 금액인 100원을 베팅합니다. 이전 판의 2배를 걸어야 하는 상황에서 수중의 돈이 모자라는 경우에는 남은 돈 전부를 건다고 가정합니다. 모든 돈을 잃게 될 경우에는 즉시 게임을 중단하고 더 이상 남은 게임을 진행하지 않습니다.

초기 금액을 나타내는 money와, 당신이 예측한 동전의 면을 순서대로 나타내는 배열 expected, 실제로 나온 동전의 면을 순서대로 나타내는 배열 actual이 매개변수로 주어집니다. 위 문단에 서술된 방식대로 돈을 베팅했을 때, 게임이 끝나고 남은 금액을 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- money는 1,000 이상 100,000 이하인 자연수입니다.
- expected와 actual의 길이는 같습니다.
- expected와 actual의 길이는 1 이상 10,000 이하입니다.
  - expected와 actual의 원소는 `'H'` 또는 `'T'`이며 각각 동전의 앞면과 뒷면을 나타냅니다.

------

##### 입출력 예

| money | expected                              | actual                                | result |
| ----- | ------------------------------------- | ------------------------------------- | ------ |
| 1000  | `['H', 'T', 'H', 'T', 'H', 'T', 'H']` | `['T', 'T', 'H', 'H', 'T', 'T', 'H']` | 1400   |
| 1200  | `['T', 'T', 'H', 'H', 'H']`           | `['H', 'H', 'T', 'H', 'T']`           | 900    |
| 1500  | `['H', 'H', 'H', 'T', 'H']`           | `['T', 'T', 'T', 'H', 'T']`           | 0      |

------

##### 입출력 예 설명

입출력 예 #1

아래 표는 게임 진행 과정을 나타냅니다.

| 베팅금액 | expected | actual | 승패 | 남은 돈 |
| -------- | -------- | ------ | ---- | ------- |
| 100      | H        | T      | 패   | 900     |
| 200      | T        | T      | 승   | 1100    |
| 100      | H        | H      | 승   | 1200    |
| 100      | T        | H      | 패   | 1100    |
| 200      | H        | T      | 패   | 900     |
| 400      | T        | T      | 승   | 1300    |
| 100      | H        | H      | 승   | 1400    |

따라서 남은 돈 1400을 return 합니다.

입출력 예 #2

아래 표는 게임 진행 과정을 나타냅니다.

| 베팅금액 | expected | actual | 승패 | 남은 돈 |
| -------- | -------- | ------ | ---- | ------- |
| 100      | T        | H      | 패   | 1100    |
| 200      | T        | H      | 패   | 900     |
| 400      | H        | T      | 패   | 500     |
| 500      | H        | H      | 승   | 1000    |
| 100      | H        | T      | 패   | 900     |

따라서 남은 돈 900을 return 합니다.

입출력 예 #3

아래 표는 게임 진행 과정을 나타냅니다.

| 베팅금액 | expected | actual | 승패 | 남은 돈 |
| -------- | -------- | ------ | ---- | ------- |
| 100      | H        | T      | 패   | 1400    |
| 200      | H        | T      | 패   | 1200    |
| 400      | H        | T      | 패   | 800     |
| 800      | T        | H      | 패   | 0       |

4번째 게임이 끝났을 때 남은 돈이 0이기 때문에 즉시 게임을 중단하고 더 이상 남은 게임을 진행하지 않습니다. 따라서 남은 돈 0을 return 합니다.

# 4

###### 문제 설명

1부터 n2 까지 순서대로 숫자를 지우는 게임이 있습니다. 게임 보드는 가로, 세로 길이가 n으로 같은 정사각 격자 형태이며, 각 칸에는 1부터 n2 까지의 숫자가 하나씩 쓰여 있습니다. 상하좌우로 1칸씩 커서를 이동하여 숫자를 선택하고, 엔터키로 숫자를 지울 수 있습니다. 게임의 완료 조건은 모든 숫자가 지워지는 것으로, 당신은 게임을 가능한 한 빨리 완료하기 위해 커서의 이동 횟수를 최소화하려고 합니다.

아래 그림은 n이 3인 게임 보드를 나타냅니다.

![Untitled Diagram.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/35052d18-4fab-441c-afa0-7422b43bfd7c/Untitled%20Diagram.png)

게임이 시작되면 커서는 보드의 가장 왼쪽 위에 위치합니다. 커서는 상하좌우로 한 칸씩 움직일 수 있으며, 이때 이동키를 한 번 눌러야 합니다. 보드는 위아래와 좌우가 연결되어 있어서 커서가 가장 왼쪽 열에 있을 때 한번 더 왼쪽으로 가면 해당 행의 제일 오른쪽 열로 이동하며, 그 반대도 가능합니다. 위아래도 마찬가지로, 커서가 가장 위쪽 행에 있을 때 한번 더 위쪽으로 가면 해당 열의 제일 아래쪽 행으로 이동하며 그 반대도 가능합니다.

예를 들어, 위 그림과 같이 커서가 숫자 3에 있을 때 숫자 1을 지우기 위해 키를 최소 3번 이상 눌러야 합니다. 초기 커서 위치에서 `위쪽 → 오른쪽` 키를 눌러 2번 만에 숫자 1로 이동한 뒤 `엔터`키를 눌러 숫자 1을 지울 수 있습니다.

게임 보드 한 변의 길이 n과, 보드 내의 숫자를 나타내는 2차원 배열 board가 매개변수로 주어집니다. 게임을 완료하기 위해 키를 눌러야 하는 최소 횟수를 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- n은 2 이상 30 이하인 자연수입니다.
- board의 행과 열의 길이는 n으로 같습니다.
- board의 원소는 1 이상 n2 이하인 자연수이며 중복이 존재하지 않습니다.

------

##### 입출력 예

| n    | board                                                        | result |
| ---- | ------------------------------------------------------------ | ------ |
| 3    | `[[3, 5, 6], [9, 2, 7], [4, 1, 8]]`                          | 22     |
| 2    | `[[2, 3], [4, 1]]`                                           | 11     |
| 4    | `[[11, 9, 8, 12], [2, 15, 4, 14], [1, 10, 16, 3], [13, 7, 5, 6]]` | 46     |

------

##### 입출력 예 설명

입출력 예 #1

문제 예시와 같은 보드입니다. 다음 과정을 통해 모든 숫자를 지울 수 있습니다.

```
1 지우기: 위쪽 → 오른쪽 → 엔터
2 지우기: 위쪽 → 엔터
3 지우기: 위쪽 → 왼쪽 → 엔터
4 지우기: 위쪽 → 엔터
5 지우기: 오른쪽 → 아래쪽 → 엔터
6 지우기: 오른쪽 → 엔터
7 지우기: 아래쪽 → 엔터
8 지우기: 아래 → 엔터
9 지우기: 위 → 오른쪽 → 엔터
```

키를 22번 누르면 모든 숫자를 지울 수 있으며 이것이 최소 횟수입니다. 따라서 22를 return 해야 합니다.

입출력 예 #2

다음 과정을 통해 모든 숫자를 지울 수 있습니다.

```
1 지우기: 오른쪽 → 아래쪽 → 엔터
2 지우기: 위쪽 → 왼쪽 → 엔터
3 지우기: 아래쪽 → 엔터
4 지우기: 오른쪽 → 위쪽 → 엔터
```

키를 11번 누르면 모든 숫자를 지울 수 있으며 이것이 최소 횟수입니다. 따라서 11를 return 해야 합니다.

입출력 예 #3
설명 생략

# 5

###### 문제 설명

0과 1로 구성된 어떤 이진 문자열 penter, pexit, pescape가 있습니다. 당신은 단일 문자열로 구성된 청크 데이터 data를 패킷(Packet)으로 포장하고자 합니다. penter, pexit, pescape는 서로 길이가 같으며, data를 구성하는 모든 원소의 길이는 penter의 길이와 같습니다. 예를 들어, penter의 길이가 4라면 data는 길이가 4인 이진 원소들로 합쳐진 문자열입니다.

data를 패킷으로 포장한다는 것은, data 앞에 penter를, data 뒤에 pexit을 붙이는 것을 말합니다. 이때, data 내부에 있는 원소들 중 penter, pdata, pescape와 동일한 원소가 있다면 컴퓨터가 패킷을 잘못 해석할 수 있으므로, 그 원소 앞에 pescape를 삽입해줘야 합니다.

다음 그림은 penter, pexit, pescape, data가 주어졌을 때 data를 패킷으로 포장하는 예시를 나타낸 것입니다.

![ex2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/761f32d7-7ecc-498f-857c-939e03bf13cb/ex2.png)

- penter = 10, pexit = 11, pescape = 00 입니다.
- data = 00011011 입니다.
- data의 맨 앞에 penter가 삽입되었고, 맨 뒤에 pexit이 삽입되었습니다.
- data에 들어있던 10, 11, 00 원소들은 각각 penter, pexit, pescape와 겹치므로, 해당하는 각 원소들 앞에 pescape가 삽입되었습니다.
- data를 패킷으로 포장한 결과는 100000010010001111 이 됩니다.

문자열 penter, pexit, pescape, 그리고 data가 매개변수로 주어집니다. data를 패킷으로 포장한 결과를 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- penter, pexit, pescape, data는 모두 0과 1로 구성된 문자열입니다.
- penter의 길이는 2 이상 100 이하입니다.
- penter, pexit, pescape는 서로 다릅니다.
- data의 길이는 1 이상 100,000 이하인 penter의 길이의 배수입니다.

------

##### 입출력 예

| penter   | pexit    | pescape  | data                             | result                                               |
| -------- | -------- | -------- | -------------------------------- | ---------------------------------------------------- |
| `"1100"` | `"0010"` | `"1001"` | `"1101100100101111001111000000"` | `"110011011001100110010010111100111001110000000010"` |
| `"10"`   | `"11"`   | `"00"`   | `"00011011"`                     | `"100000010010001111"`                               |

------

##### 입출력 예 설명

입출력 예 #1

- penter, pexit, pescape의 길이가 4이므로, data는 길이가 4인 원소로 구성되어 있습니다.
- 다음 그림은 data를 4개 비트 단위로 쪼갠 뒤 다시 합치는 과정을 나타낸 것입니다.

![ex1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/769e94dd-2c7f-411a-8e45-c0ee71c8bcd3/ex1.png)

- data에 들어있던 1100, 0010, 1001 원소들은 각각 penter, pexit, pescape와 겹치므로, 해당하는 각 원소들 앞에 pescape가 삽입되었습니다.
- 따라서, 110011011001100110010010111100111001110000000010을 return 해야 합니다.

입출력 예 #2

- 문제 예시와 같습니다.

# 6

###### 문제 설명

온라인으로 시험을 보는 프로그래밍 학원이 있습니다. 모든 시험 문제는 프로그램에 의해 자동으로 채점되며, 부분점수가 부여됩니다. 채점은 답안 제출과 동시에 실시간으로 이루어지며, 채점 로그가 시험 관리자에게 전달됩니다. 관리자는 시험이 모두 끝난 후 채점 로그를 통해 부정행위자로 의심되는 사람들을 찾아내려고 합니다. 이를 위해 다음과 같은 조건을 정했습니다.

```
1. 두 수험자가 푼 문제 수가 같다. 단, 푼 문제 수가 5 미만인 경우는 제외한다.
2. 두 수험자가 푼 문제의 번호가 모두 같다.
3. 두 수험자가 푼 문제의 점수가 모두 같다.
```

임의의 두 수험자가 위 3가지 조건에 모두 부합하는 경우, 두 수험자를 부정행위자로 의심합니다.

수험자의 수험번호, 문제 번호, 받은 점수를 나타내는 문자열 배열 logs가 매개변수로 주어집니다. 위 조건에 해당하는 모든 부정행위 의심자의 수험번호를 배열에 담아 사전 순으로 정렬하여 return 하도록 solution 함수를 완성해주세요. 단, 부정행위자로 의심되는 수험자가 없는 경우에는 문자열 None을 배열에 담아 return 해주세요.

------

##### 제한사항

- logs의 길이는 1 이상 5,000 이하입니다.
  - logs의 원소는 한 수험자가 한 문제를 풀었을 때 받은 점수를 나타냅니다.
  - logs의 원소는 수험번호 문제번호 점수 형식의 문자열입니다.
  - 수험번호는 길이가 4인 문자열이며 숫자로만 이루어져 있습니다.
  - 문제번호는 1 이상 100 이하인 자연수입니다.
  - 점수는 0 이상 100 이하인 정수입니다.
  - 문제를 풀지 않은 경우는 logs에 기록되지 않습니다.
- 한 수험자가 같은 문제에 대해 여러 번 답안을 제출할 수 있습니다. 단, 마지막 제출의 채점 결과가 최종 점수입니다.
  - 0점을 받는 답안 제출도 문제를 푼 것으로 칩니다.

------

##### 입출력 예

| logs                                                         | result                     |
| ------------------------------------------------------------ | -------------------------- |
| `["0001 3 95", "0001 5 90", "0001 5 100", "0002 3 95", "0001 7 80", "0001 8 80", "0001 10 90", "0002 10 90", "0002 7 80", "0002 8 80", "0002 5 100", "0003 99 90"]` | `["0001", "0002"]`         |
| `["1901 1 100", "1901 2 100", "1901 4 100", "1901 7 100", "1901 8 100", "1902 2 100", "1902 1 100", "1902 7 100", "1902 4 100", "1902 8 100", "1903 8 100", "1903 7 100", "1903 4 100", "1903 2 100", "1903 1 100", "2001 1 100", "2001 2 100", "2001 4 100", "2001 7 95", "2001 9 100", "2002 1 95", "2002 2 100", "2002 4 100", "2002 7 100", "2002 9 100"]` | `["1901", "1902", "1903"]` |
| `["1901 10 50", "1909 10 50"]`                               | `["None"]`                 |

------

##### 입출력 예 설명

입출력 예 #1

입력 로그는 다음과 같습니다.

```
0001 3 95
0001 5 100
0001 5 90
0002 3 95
0001 7 80
0001 8 80
0001 10 90
0002 10 90
0002 7 80
0002 8 80
0002 5 90
0003 99 90
```

0001번 수험자는 문제 3번을 95점, 5번을 90점(마지막 제출 기준), 7번을 80점, 8번을 80점, 10번을 90점 받았습니다. 0002번 수험자는 0001번 수험자와 완전히 같은 문제를 풀어 같은 점수를 받았으며, 두 수험자가 푼 문제 수는 5개입니다. 따라서 0001번 수험자와 0002번 수험자는 부정행위자로 의심됩니다. 따라서 수험번호 0001과 0002를 배열에 담아 사전 순으로 정렬한 후 return 합니다.

입출력 예 #2
입력 로그는 다음과 같습니다.

```
1901 1 100
1901 2 100
1901 4 100
1901 7 100
1901 8 100
1902 2 100
1902 1 100
1902 7 100
1902 4 100
1902 8 100
1903 8 100
1903 7 100
1903 4 100
1903 2 100
1903 1 100
2001 1 100
2001 2 100
2001 4 100
2001 7 95
2001 9 100
2002 1 95
2002 2 100
2002 4 100
2002 7 100
2002 9 100
```

1901번 수험자, 1902번 수험자, 1903번 수험자는 모두 같은 문제 5개를 풀고, 같은 점수를 받았습니다. 따라서 세 사람은 한 그룹의 부정행위자로 의심됩니다. 2001번 수험자와 2002번 수험자는 같은 문제 5개를 풀었지만 1번 문제와 7번 문제의 점수가 서로 다르기 때문에 부정행위자로 의심받지 않습니다. 따라서 수험번호 1901, 1902, 1903을 배열에 담아 사전 순으로 정렬한 후 return 합니다.

입출력 예 #3
부정행위자로 의심받는 사람이 없으므로 [None]을 return 합니다.

# 7

###### 문제 설명

당신은 로봇 청소기의 개발자입니다. 다음은 정사각형 모양의 방을 청소할 때 로봇 청소기의 특징을 나열한 것입니다.

- 로봇 청소기는 방의 최상단 좌측부터 최하단 우측까지 `대각선-지그재그` 모양의 동선에서 움직이면서 청소를 합니다.
- 로봇 청소기는 수평/수직방향으로 이동하는 데 1칸당 1초, 대각선 방향으로 이동하는 데 1칸당 2초가 걸립니다.
- 로봇 청소기가 처음 움직이는 방향을 오른쪽과 아래쪽 중에서 선택할 수 있습니다.

방의 한 변의 길이(단위: 칸) n과 로봇 청소기가 처음으로 움직이는 방향이 오른쪽인지 여부를 나타내는 진리값 horizontal이 매개변수로 주어집니다. 시작 지점을 0초에 도달했다고 했을 때, 방의 각 칸에 대해서 로봇 청소기가 몇 초 후에 도달하는지를 2차원 배열에 담아 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- n은 1 이상 100 이하입니다.

------

##### 입출력 예

| n    | horizontal | result                                                       |
| ---- | ---------- | ------------------------------------------------------------ |
| 4    | true       | `[[0,1,8,9],[3,6,11,20],[4,13,18,21],[15,16,23,24]]`         |
| 5    | false      | `[[0,3,4,15,16],[1,6,13,18,31],[8,11,20,29,32],[9,22,27,34,39],[24,25,36,37,40]]` |

------

##### 입출력 예 설명

입출력 예 #1

- 로봇 청소기의 이동 경로와 각 칸에 도착하는 시간(초)은 다음과 같습니다.
- ![ex1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d193ceb2-2c62-4b84-8688-9d2a7998eb1d/ex1.png)

입출력 예 #2

- 로봇 청소기의 이동 경로와 각 칸에 도착하는 시간(초)은 다음과 같습니다.
- ![ex2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4d88ca85-5c4c-48f2-944e-58daa9d945fe/ex2.png)